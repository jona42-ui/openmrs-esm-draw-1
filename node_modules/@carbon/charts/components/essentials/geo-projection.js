var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// Internal Imports
import { Component } from '../component';
import { DOMUtils } from '../../services';
import * as Tools from '../../tools';
import { RenderTypes, Projection } from '../../interfaces';
// D3 imports
import { geoPath, line } from 'd3';
import { feature, merge } from 'topojson-client';
import { 
// Azimuthal Projections - project the sphere directly on to the plane
geoEqualEarth, 
// Conic projections - project the sphere onto a cone & unroll into the plane
geoAlbers, geoConicEqualArea, geoConicEquidistant, 
// Cylindrical projections - project the sphere onto a containing cylinder & unroll onto the plane
geoEquirectangular, geoMercator, geoNaturalEarth1, } from 'd3-geo';
var GeoProjection = /** @class */ (function (_super) {
    __extends(GeoProjection, _super);
    function GeoProjection() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'geo';
        _this.renderType = RenderTypes.SVG;
        return _this;
    }
    GeoProjection.prototype.render = function () {
        var svg = this.getComponentContainer({ withinChartClip: true });
        var _a = DOMUtils.getSVGElementSize(svg, {
            useAttrs: true,
        }), width = _a.width, height = _a.height;
        // Because of a Firefox bug with regards to sizing & d3 packs,
        // rather than checking if height or width aren't 0,
        // we have to make sure they're not smaller than 1
        if (width < 1 || height < 1) {
            return;
        }
        // Get users projection
        var projection = this.getProjection();
        var geoData = Tools.getProperty(this.getOptions(), 'geoData');
        var data = this.model.getCombinedData();
        // Seperate countries that have data & countries with missing data
        var withData = {};
        var withoutData = {};
        Object.keys(data).forEach(function (element) {
            if (typeof data[element].value === 'number') {
                withData[element] = data[element];
            }
            else {
                withoutData[element] = data[element];
            }
        });
        // Merge all without data
        var withoutDataMerge = merge(geoData, Object.values(withoutData));
        /**
         * @todo - Currently only topojson is supported
         *
         * Unlike geojson, topojson does not have a standard format
         * So data must be nested in the following format:
         * options : {
         * 	geoData: {
         *  	objects: {
         * 			...
         * 		}
         *  }
         * }
         */
        // Convert from topojson to geojson
        var json = feature(geoData, {
            // We need to specify that we are converting geometry collections
            type: 'GeometryCollection',
            geometries: Object.values(withData),
        });
        // Depending on the projection selected, we will need to scale/translate accordingly
        var projectionScale = projection.fitSize([width, height], json);
        var geo = geoPath().projection(projectionScale);
        var borders = DOMUtils.appendOrSelect(svg, 'g.geo');
        borders
            .selectAll('path')
            .data(json.features)
            .join('path')
            .attr('d', geo);
        var patternID = this.services.domUtils.generateElementIDString("geo-pattern-stripes");
        // Create a striped pattern for missing data
        var defs = DOMUtils.appendOrSelect(svg, 'defs');
        DOMUtils.appendOrSelect(defs, 'pattern')
            .attr('id', patternID)
            .attr('width', 5)
            .attr('height', 10)
            .attr('patternUnits', 'userSpaceOnUse')
            .attr('patternTransform', 'rotate(45)')
            .append('path')
            .classed('pattern-fill', true)
            .attr('d', line()([
            [0, 0],
            [0, 10],
        ]));
        var missingBorders = DOMUtils.appendOrSelect(svg, 'g.missing-data');
        DOMUtils.appendOrSelect(missingBorders, 'path')
            .datum(withoutDataMerge)
            .attr('d', geo)
            .style('fill', "url(#" + patternID + ")");
    };
    /**
     * @info
     * Depending on projection, we may need to provide additional configuration
     * e.g. sizing
     *
     * In such case, function can be refactored so that
     * projection should return an object with the configuraiton & function
     */
    GeoProjection.prototype.getProjection = function () {
        var projection = null;
        var projectionSelected = Tools.getProperty(this.getOptions(), 'thematic', 'projection');
        switch (projectionSelected) {
            // Azimuthal Projections
            case Projection.geoEqualEarth:
                projection = geoEqualEarth();
                break;
            // Conic Projections
            case Projection.geoAlbers:
                projection = geoAlbers();
                break;
            case Projection.geoConicEqualArea:
                projection = geoConicEqualArea();
                break;
            case Projection.geoConicEquidistant:
                projection = geoConicEquidistant();
                break;
            // Cyndrical projections
            case Projection.geoEquirectangular:
                projection = geoEquirectangular();
                break;
            case Projection.geoMercator:
                projection = geoMercator();
                break;
            case Projection.geoNaturalEarth1:
                projection = geoNaturalEarth1();
                break;
            default:
                // Projection is missing or an unsupported projection value is passed
                throw new Error('Projection is not supported.');
                break;
        }
        return projection;
    };
    return GeoProjection;
}(Component));
export { GeoProjection };
//# sourceMappingURL=../../../src/components/essentials/geo-projection.js.map