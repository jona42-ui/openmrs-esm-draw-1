"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runAssemble = void 0;
const promises_1 = require("fs/promises");
const path_1 = require("path");
const inquirer_1 = require("inquirer");
const rimraf_1 = __importDefault(require("rimraf"));
const axios_1 = __importDefault(require("axios"));
const npm_registry_fetch_1 = __importDefault(require("npm-registry-fetch"));
const pacote_1 = __importDefault(require("pacote"));
const utils_1 = require("../utils");
const fs_1 = require("fs");
const npmConfig_1 = require("../utils/npmConfig");
function readConfig(mode, config, fetchOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (mode) {
            case "config":
                if (!(0, fs_1.existsSync)(config)) {
                    throw new Error(`Could not find the config file "${config}".`);
                }
                (0, utils_1.logInfo)(`Reading configuration ...`);
                return Object.assign({ baseDir: (0, path_1.dirname)(config) }, JSON.parse(yield (0, promises_1.readFile)(config, "utf8")));
            case "survey":
                (0, utils_1.logInfo)(`Loading available frontend modules ...`);
                const packages = yield npm_registry_fetch_1.default
                    .json("/-/v1/search?text=keywords:openmrs&size=500", fetchOptions)
                    .then((res) => res)
                    .then((res) => res.objects
                    .map((m) => ({
                    name: m.package.name,
                    version: m.package.version,
                }))
                    .filter((m) => m.name.endsWith("-app")));
                const questions = [];
                for (const pckg of packages) {
                    questions.push({
                        name: pckg.name,
                        message: `Include frontend module "${pckg.name}"?`,
                        default: false,
                        type: "confirm",
                    }, {
                        name: pckg.name,
                        askAnswered: true,
                        message: `Version for "${pckg.name}"?`,
                        default: pckg.version,
                        type: "string",
                        when(ans) {
                            return ans[pckg.name];
                        },
                    });
                }
                const answers = yield (0, inquirer_1.prompt)(questions);
                return {
                    baseDir: process.cwd(),
                    publicUrl: ".",
                    frontendModules: Object.keys(answers)
                        .filter((m) => answers[m])
                        .reduce((prev, curr) => {
                        prev[curr] = answers[curr];
                        return prev;
                    }, {}),
                };
        }
        return {
            baseDir: process.cwd(),
            frontendModules: {},
            publicUrl: ".",
        };
    });
}
function downloadPackage(cacheDir, esmName, esmVersion, baseDir, fetchOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(0, fs_1.existsSync)(cacheDir)) {
            yield (0, promises_1.mkdir)(cacheDir, { recursive: true });
        }
        if (esmVersion.startsWith("file:")) {
            const source = (0, path_1.resolve)(baseDir, esmVersion.substring(5));
            const file = (0, path_1.basename)(source);
            const target = (0, path_1.resolve)(cacheDir, file);
            yield (0, promises_1.copyFile)(source, target);
            return file;
        }
        else if (/^https?:\/\//.test(esmVersion)) {
            const response = yield axios_1.default.get(esmVersion);
            const content = response.data;
            const file = esmName.replace("@", "").replace(/\//g, "-") + ".tgz";
            yield (0, promises_1.writeFile)((0, path_1.resolve)(cacheDir, file), content);
            return file;
        }
        else {
            const packageName = `${esmName}@${esmVersion}`;
            const tarManifest = yield pacote_1.default.manifest(packageName, fetchOptions);
            if (!Boolean(tarManifest) ||
                !Boolean(tarManifest._resolved) ||
                !Boolean(tarManifest._integrity)) {
                throw new Error(`Failed to load manifest for ${packageName} from registry ${fetchOptions.registry}`);
            }
            const tarball = yield pacote_1.default.tarball(tarManifest._resolved, Object.assign(Object.assign({}, fetchOptions), { integrity: tarManifest._integrity }));
            const filename = `${tarManifest.name}-${tarManifest.version}.tgz`
                .replace(/^@/, "")
                .replace(/\//, "-");
            yield (0, promises_1.writeFile)((0, path_1.resolve)(cacheDir, filename), tarball);
            return filename;
        }
    });
}
function extractFiles(sourceFile, targetDir) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        yield (0, promises_1.mkdir)(targetDir, { recursive: true });
        const packageRoot = "package";
        const rs = (0, fs_1.createReadStream)(sourceFile);
        const files = yield (0, utils_1.untar)(rs);
        const packageJson = JSON.parse(files[`${packageRoot}/package.json`].toString("utf8"));
        const version = (_a = packageJson.version) !== null && _a !== void 0 ? _a : "0.0.0";
        const entryModule = (_c = (_b = packageJson.browser) !== null && _b !== void 0 ? _b : packageJson.module) !== null && _c !== void 0 ? _c : packageJson.main;
        const fileName = (0, path_1.basename)(entryModule);
        const sourceDir = (0, path_1.dirname)(entryModule);
        yield Promise.all(Object.keys(files)
            .filter((m) => m.startsWith(`${packageRoot}/${sourceDir}`))
            .map((m) => __awaiter(this, void 0, void 0, function* () {
            const content = files[m];
            const fileName = m.replace(`${packageRoot}/${sourceDir}/`, "");
            const targetFile = (0, path_1.resolve)(targetDir, fileName);
            yield (0, promises_1.mkdir)((0, path_1.dirname)(targetFile), { recursive: true });
            yield (0, promises_1.writeFile)(targetFile, content);
        })));
        yield (0, promises_1.unlink)(sourceFile);
        return [fileName, version];
    });
}
function runAssemble(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const npmConf = (0, npmConfig_1.getNpmRegistryConfiguration)(args.registry);
        const config = yield readConfig(args.mode, args.config, npmConf);
        const importmap = {
            imports: {},
        };
        const versionManifest = {
            frontendModules: {},
        };
        const routes = {};
        (0, utils_1.logInfo)(`Assembling the importmap ...`);
        const { frontendModules = {}, publicUrl = "." } = config;
        const cacheDir = (0, path_1.resolve)(process.cwd(), ".cache");
        if (args.fresh && (0, fs_1.existsSync)(args.target)) {
            yield new Promise((resolve) => (0, rimraf_1.default)(args.target, resolve));
        }
        yield (0, promises_1.mkdir)(args.target, { recursive: true });
        yield Promise.all(Object.keys(frontendModules).map((esmName) => __awaiter(this, void 0, void 0, function* () {
            const esmVersion = frontendModules[esmName];
            const tgzFileName = yield downloadPackage(cacheDir, esmName, esmVersion, config.baseDir, npmConf);
            const dirName = tgzFileName.replace(".tgz", "");
            const [fileName, version] = yield extractFiles((0, path_1.resolve)(cacheDir, tgzFileName), (0, path_1.resolve)(args.target, dirName));
            const appRoutes = (0, path_1.resolve)(args.target, dirName, "routes.json");
            if ((0, fs_1.existsSync)(appRoutes)) {
                try {
                    routes[esmName] = JSON.parse((0, fs_1.readFileSync)(appRoutes).toString());
                    routes[esmName]["version"] = version;
                }
                catch (e) {
                    (0, utils_1.logWarn)(`Error while processing routes for ${esmName} using ${appRoutes}: ${e}`);
                }
            }
            else {
                (0, utils_1.logWarn)(`Routes file ${appRoutes} does not exist. We expect that routes file to be defined by ${esmName}. Note that this means that no pages or extensions for ${esmName} will be available.`);
                routes[esmName] = {};
            }
            importmap.imports[esmName] = `${publicUrl}/${dirName}/${fileName}`;
            versionManifest.frontendModules[esmName] = version;
        })));
        yield (0, promises_1.writeFile)((0, path_1.resolve)(args.target, `importmap${args.hashImportmap ? "." + (0, utils_1.contentHash)(importmap) : ""}.json`), JSON.stringify(importmap, undefined, 2), "utf8");
        if (args.buildRoutes) {
            yield (0, promises_1.writeFile)((0, path_1.resolve)(args.target, `routes.registry${args.hashImportmap ? "." + (0, utils_1.contentHash)(routes) : ""}.json`), JSON.stringify(routes, undefined, 2), "utf-8");
        }
        if (args.manifest) {
            yield (0, promises_1.writeFile)((0, path_1.resolve)(args.target, "spa-module-versions.json"), JSON.stringify(versionManifest, undefined, 2), "utf8");
        }
    });
}
exports.runAssemble = runAssemble;
