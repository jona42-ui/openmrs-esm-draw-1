"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runBuild = void 0;
const fs_1 = require("fs");
const utils_1 = require("../utils");
const path_1 = require("path");
function loadBuildConfig(buildConfigPath) {
    if (buildConfigPath) {
        return JSON.parse((0, fs_1.readFileSync)(buildConfigPath, "utf8"));
    }
    else {
        return {};
    }
}
function addConfigFilesFromPaths(configPaths, targetDir) {
    for (let configPath of configPaths) {
        const realPath = (0, path_1.resolve)(configPath);
        (0, fs_1.copyFileSync)(realPath, (0, path_1.join)(targetDir, (0, path_1.basename)(configPath)));
    }
}
function runBuild(args) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const webpack = require("webpack");
        const buildConfig = loadBuildConfig(args.buildConfig);
        const configUrls = buildConfig.configUrls || args.configUrls;
        for (let configPath of buildConfig.configPaths || args.configPaths) {
            configUrls.push((0, path_1.basename)(configPath));
        }
        const importMap = yield (0, utils_1.getImportMap)(buildConfig.importmap || args.importmap);
        // if we're supplying a URL importmap and the dist folder exists and the raw importmap file doesn't exist
        // we use the nearest thing. Basically, this is added to support the --hash-importmap assemble option.
        if (importMap.type === "url") {
            if (!/^https?:\/\//.test(importMap.value) &&
                (0, fs_1.existsSync)(args.target) &&
                !(0, fs_1.existsSync)((0, path_1.resolve)(args.target, importMap.value))) {
                const { name: fileName, ext: extension } = (0, path_1.parse)(importMap.value);
                const paths = (0, fs_1.readdirSync)(args.target).filter((entry) => entry.startsWith(fileName) &&
                    entry.endsWith(extension) &&
                    (0, fs_1.statSync)((0, path_1.resolve)(args.target, entry)).isFile());
                if (paths) {
                    importMap.value = paths[0];
                }
            }
        }
        const config = (0, utils_1.loadWebpackConfig)({
            importmap: importMap,
            env: "production",
            apiUrl: buildConfig.apiUrl || args.apiUrl,
            configUrls: configUrls,
            defaultLocale: args.defaultLocale || buildConfig.defaultLocale,
            pageTitle: buildConfig.pageTitle || args.pageTitle,
            supportOffline: (_a = buildConfig.supportOffline) !== null && _a !== void 0 ? _a : args.supportOffline,
            spaPath: buildConfig.spaPath || args.spaPath,
            fresh: (_b = args.fresh) !== null && _b !== void 0 ? _b : false,
        });
        (0, utils_1.logInfo)(`Running build process ...`);
        const compiler = webpack(Object.assign(Object.assign({}, config), { output: Object.assign(Object.assign({}, config.output), { path: args.target }) }));
        return yield new Promise((resolve, reject) => {
            compiler.run((err, stats) => {
                if (err) {
                    reject(err);
                }
                else {
                    stats &&
                        console.log(stats.toString({
                            colors: true,
                        }));
                    addConfigFilesFromPaths(buildConfig.configPaths || args.configPaths, args.target);
                    (0, utils_1.logInfo)(`Build finished.`);
                    resolve();
                }
            });
        });
    });
}
exports.runBuild = runBuild;
