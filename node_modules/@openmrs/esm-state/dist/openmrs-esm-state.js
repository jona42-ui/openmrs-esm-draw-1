System.register([],(function(e,t){return{execute:function(){e((()=>{"use strict";var e={d:(t,r)=>{for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{createAppState:()=>c,createGlobalStore:()=>a,getAppState:()=>i,getGlobalStore:()=>u,subscribeTo:()=>s});const r=e=>{let t;const r=new Set,n=(e,n)=>{const o="function"==typeof e?e(t):e;if(!Object.is(o,t)){const e=t;t=(null!=n?n:"object"!=typeof o)?o:Object.assign({},t,o),r.forEach((r=>r(t,e)))}},o=()=>t,a={setState:n,getState:o,subscribe:e=>(r.add(e),()=>r.delete(e)),destroy:()=>{console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),r.clear()}};return t=e(n,o,a),a},n=e=>e?r(e):r;var o={};function a(e,t){var r=o[e];if(r)return r.active?console.error("Cannot override an existing store. Make sure that stores are only created once."):r.value.setState(t,!0),r.active=!0,r.value;var a=n()((function(){return t}));return o[e]={value:a,active:!0},a}function u(e,t){var r=o[e];if(!r){var a=n()((function(){return null!=t?t:{}}));return o[e]={value:a,active:!1},a}return r.value}function c(e){return a("app",e)}function i(){return u("app",{})}function s(e,t,r){var n=t(e.getState());return e.subscribe((function(e){var o=t(e);o!==n&&(n=o,r(o))}))}return t})())}}}));
//# sourceMappingURL=openmrs-esm-state.js.map